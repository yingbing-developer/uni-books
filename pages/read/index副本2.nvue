<template>
	<view class="read" :style="{'background-color': skinColor.readBackColor}">
		<nav-bar :bgColor="skinColor.readBackColor" :title="bookInfo.name" :titleColor="skinColor.readTextColor" :backColor="skinColor.readTextColor">
			<view class="nav-right" slot="right">
				<!-- <text class="nav-right-text" :style="{'color': skinColor.textColor}">{{pageIndex}}/{{totalPage}}</text> -->
				<text class="nav-right-text" :style="{'color': skinColor.textColor}">{{progress}}%</text>
			</view>
		</nav-bar>
		<view class="list-view" :class="{'opacClass': listShow}" ref="listView">
			<view :style="{height: viewHeight + 'px'}">
				<list @scroll="scroll" :scrollable="scrollMode == 'upDown'" :show-scrollbar="scrollMode == 'upDown'">
					<cell v-for="(item, index) in bookContent" :key="item + index">
						<view class="content" @disappear="ondisappear">
							<text
							ref="text"
							:style="{
							'font-size': fontSize + 'px',
							'line-height': (fontSize + 15) + 'px',
							color: skinColor.readTextColor}">{{item}}</text>
						</view>
					</cell>
				</list>
			</view>
			<view class="touchBoard">
				<view class="touch-box touch-left" v-if="scrollMode == 'leftRight'">
					<view class="touch-item" @tap="prevPage"></view>
				</view>
				<view class="touch-box touch-center">
					<view class="touch-item" @tap="$refs.readSetting.show()"></view>
				</view>
				<view class="touch-box touch-right" v-if="scrollMode == 'leftRight'">
					<view class="touch-item" @tap="nextPage"></view>
				</view>
			</view>
		</view>
		<read-setting
		:path="path"
		:totalPage="totalPage"
		:progress="progress"
		ref="readSetting"
		@pageTo="goPage"></read-setting>
		<!-- 隐藏的一行文本用于获取一行字的真实高度 -->
		<text
		ref="lineHeight"
		class="lineHeight"
		:style="{
		'font-size': fontSize + 'px',
		'line-height': (fontSize + 15) + 'px',}">一</text>
	</view>
</template>

<script>
	import { mapGetters, mapMutations } from 'vuex'
	import { skinMixin } from '@/common/mixin/index.js'
	import { indexOf } from '@/common/js/util.js'
	import ReadSetting from './setting.nvue'
	const dom = weex.requireModule('dom');
	const pageSize = 1000;
	export default {
		mixins: [skinMixin],
		data () {
			return {
				//是否显示文本容器
				listShow: false,
				//小说内容
				bookContent: [],
				//文本容器实际高度
				listHeight: 0,
				//字符实际行高
				lineHeight: 0,
				//文本内容实际高度
				textHeight: 0
			}
		},
		computed: {
			...mapGetters(['readMode', 'bookList']),
			path () {
				const pages = getCurrentPages();
				const page = pages[pages.length - 1];
				return page.options.path;
			},
			//书籍信息
			bookInfo () {
				return this.bookList[indexOf(this.bookList, this.path, 'path')];
			},
			//页数
			pageIndex () {
				return this.bookInfo.pageIndex
			},
			//字体大小
			fontSize () {
				return this.readMode.fontSize;
			},
			//滚动方式
			scrollMode () {
				return this.readMode.scroll;
			},
			//行数
			textLine () {
				return parseInt(this.listHeight / this.lineHeight);
			},
			//当前页面的字符应该占的高度
			viewHeight () {
				return this.textLine * this.lineHeight;
			},
			//总页数
			totalPage () {
				return this.textHeight % this.viewHeight > 0 ? parseInt(this.textHeight / this.viewHeight) + 1 : parseInt(this.textHeight / this.viewHeight);
			},
			//阅读进度
			progress () {
				return this.bookContent.length > 0 ? (((this.pageIndex - 1) * this.viewHeight) / this.textHeight * 100).toFixed(2) : '0.00';
			}
		},
		created () {
			this.getContent();
		},
		methods: {
			...mapMutations(['updateBookProgress', 'updateBookPage']),
			// getContent () {
			// 	let ReadTxt = plus.android.importClass('com.itstudy.io.GetText');
			// 	let readTxt = new ReadTxt();
			// 	let content = readTxt.getTextFromText(plus.io.convertLocalFileSystemURL(this.path));
			// 	//将内容按每1000字依次存入数组
			// 	this.$nextTick(() => {
			// 		for ( let i = 0; i < Math.ceil(content.length / 1000); i++ ) {
			// 			this.bookContent.push(content.substr(i * 1000, 1000));
			// 		}
			// 		this.$nextTick(async () => {
			// 			this.listHeight = await this.getDomHeight('listView');
			// 			this.lineHeight = await this.getDomHeight('lineHeight');
			// 			for ( let i in this.bookContent ) {
			// 				this.textHeight += await this.getDomHeight('text', i);
			// 			}
			// 			//第一次加载内容时初始化页数，偏移值
			// 			this.scrollTo();
			// 			setTimeout(() => {
			// 				this.listShow = true;
			// 			}, 50)
			// 		})
			// 	})
			// },
			getContent () {
				plus.io.resolveLocalFileSystemURL('file://' + this.path, ( entry ) => {
					entry.file( ( file ) => {
						let slice = file.slice(this.pageIndex, this.pageIndex + pageSize);
						let reader = new plus.io.FileReader();
						reader.onloadend = ( e ) => {
							let result = e.target.result;
							for ( let i = 0; i < Math.ceil(result.length / 1000); i++ ) {
								this.bookContent.push(result.substr(i * 1000, 1000));
							}
							this.$nextTick(async () => {
								this.listHeight = await this.getDomHeight('listView');
								this.lineHeight = await this.getDomHeight('lineHeight');
								for ( let i in this.bookContent ) {
									this.textHeight += await this.getDomHeight('text', i);
								}
								//第一次加载内容时初始化页数，偏移值
								this.scrollTo();
								setTimeout(() => {
									this.listShow = true;
								}, 50)
							})
						};
						reader.readAsText( slice, 'utf-8' );
					}, ( fail ) => {
						console.log("Request file system failed: " + fail.message);
					});
				}, ( fail ) => {
					console.log( "Request file system failed: " + fail.message );
				});
			},
			//获取元素高度
			getDomHeight (query, index) {
				let el = index >= 0 ? this.$refs[query][index] : this.$refs[query];
				return new Promise((resolve, reject) => {
					dom.getComponentRect(el, (res) => {
						resolve(res.size.height);
					})
				})
			},
			//上一页
			prevPage () {
				if ( this.pageIndex == 1 ) {
					uni.showToast({
						icon: 'none',
						title: '已经是第一页了'
					})
					return;
				}
				this.goPage(this.pageIndex - 1);
			},
			//下一页
			nextPage () {
				if ( this.pageIndex >= this.totalPage ) {
					uni.showToast({
						icon: 'none',
						title: '已经是最后一页了'
					})
					return;
				}
				this.goPage(this.pageIndex + 1);
			},
			//前往页面
			goPage (page) {
				let book = {
					path: this.path,
					page: page
				}
				this.updateBookPage(book);
				this.upProgress(this.progress);
				this.scrollTo();
			},
			//更新书籍阅读进度
			upProgress (progress) {
				let book = {
					path: this.path,
					progress: progress
				}
				this.updateBookProgress(book);
			},
			//监听滚动事件
			scroll (e) {
				//等待页面初始化完成
				if ( !this.listShow ) {
					return;
				}
				let offsetY = Math.abs(e.contentOffset.y);
				let book = {
					path: this.path,
					page: offsetY % this.viewHeight > 0 ? parseInt(offsetY/ this.viewHeight) + 2 : parseInt(offsetY/ this.viewHeight) + 1
				}
				this.updateBookPage(book);
				this.upProgress(this.progress);
			},
			//滚动到指定位置
			scrollTo () {
				dom.scrollToElement(this.$refs.text[0], {
					offset: (this.pageIndex - 1) * this.viewHeight,
					animated: false,
				});
			},
			ondisappear (e) {
				// console.log(e);
			}
		},
		components: {
			ReadSetting
		},
		watch: {
			fontSize (val) {
				//字体大小更改，等待文本重渲染后再次获取文本行高和文本内容实际高度
				setTimeout( async () => {
					this.lineHeight = await this.getDomHeight('lineHeight');
					this.textHeight = 0;
					for ( let i in this.bookContent ) {
						this.textHeight += await this.getDomHeight('text', i);
					}
					//字体变小会引起总页数的减少，原本的当前页数可能会超过总页数，所以需要判断当前页数大于总页数，赋值为最后一页
					if ( this.pageIndex > this.totalPage ) {
						this.goPage(this.totalPage);
					}
				}, 50)
			},
			scrollMode (val) {
				//监听翻页方式更改，如果改为左右翻页则滚动到当前页
				if ( val == 'leftRight' ) {
					this.scrollTo();
				}
			}
		}
	}
</script>

<style scoped>
	.nav-right {
		flex: 1;
		align-items: flex-end;
		padding-right: 20px;
	}
	.nav-right-text {
		font-size: 14px;
	}
	.list-view {
		flex: 1;
		justify-content: center;
		opacity: 0;
	}
	.opacClass {
		opacity: 1;
	}
	.lineHeight {
		position: absolute;
		opacity: 0;
	}
	.content {
		padding: 0 20px;
		align-items: center;
		flex: 1;
	}
	.touchBoard {
		position: absolute;
		top: 0;
		left: 0;
		right: 0;
		bottom: 0;
		flex-direction: row;
		justify-content: center;
	}
	.touch-box  {
		justify-content: center;
	}
	.touch-left {
		flex: 1;
	}
	.touch-right {
		flex: 1;
	}
	.touch-center {
		width: 200rpx;
	}
	.touch-item {
		height: 200rpx;
	}
</style>
